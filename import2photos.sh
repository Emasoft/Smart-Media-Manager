#!/bin/bash
# import2photos.sh ‚Äî macOS Photos importer (Bash 3.2 compatible)
# Architecture (v3.4.1):
#   1) MOVE_TO_STAGE_DIR:
#        ‚Ä¢ Scan target dir (default: CWD; or --from-dir), optionally --recursive.
#        ‚Ä¢ Select ONLY Photos-compatible files (same extension set as before).
#        ‚Ä¢ Stage to ./import2photos_stage_<timestamp> under CWD, preserving relative paths.
#        ‚Ä¢ Every staged filename gets a unique " (<index>)" suffix before the extension.
#        ‚Ä¢ Preserve mtime: cp -p + touch -r, then remove original.
#   2) DIRECTORY IMPORT:
#        ‚Ä¢ Import the entire staging dir in a single Photos call; add items to album.
#        ‚Ä¢ AppleScript returns imported item filenames; we reconcile against staged files
#          to produce per-file logs (imported vs skipped).
#   3) CLEANUP PROMPT: ask to Trash the staging directory.

VERSION="3.4.1"

set -o pipefail
case "${LC_CTYPE:-}${LANG:-}" in
  *UTF-8*|*utf8*) : ;;
  *) export LC_CTYPE="UTF-8"; export LANG="${LANG:-en_US.UTF-8}";;
esac

ALBUM_NAME="Imported From MacOS"
DRY_RUN=0
RECURSIVE=0
TARGET_DIR=""
SKIP_DUP_CHECK=${SKIP_DUP_CHECK:-false}

LOG_DIR="$PWD/import2photos_logs"
mkdir -p "$LOG_DIR" 2>/dev/null || true
RUN_TS="$(date "+%Y%m%d_%H%M%S")"
STAGED_LOG="$LOG_DIR/staged_${RUN_TS}.log"
IMPORTED_LOG="$LOG_DIR/imported_${RUN_TS}.log"
FAILED_LOG="$LOG_DIR/failed_${RUN_TS}.log"
DUP_LOG="$LOG_DIR/duplicates_${RUN_TS}.log"
WARN_LOG="$(mktemp -t import2photos_warn.XXXXXX 2>/dev/null || echo "/tmp/import2photos_warn.$$.log")"

warn() { echo "$@" | tee -a "$WARN_LOG" >&2; }

print_help() {
  cat <<EOF
macOS to Photos Import Script v$VERSION

Usage:
  import2photos.sh [--from-dir <path>] [--recursive] [--dry-run]
                   [--album <album name>]
                   [--skip-dup-check | --no-skip-dup-check]
                   [-h|--help] [-V|--version]

What it does:
  1) MOVE_TO_STAGE_DIR: scans the target folder (default: current directory; or --from-dir)
     for Apple Photos-compatible files and moves them into
     ./import2photos_stage_<timestamp>, preserving relative paths.
     Each staged filename is made unique by appending " (<index>)" before the extension.
     File modification times are preserved.
  2) IMPORT: imports the entire staging directory in ONE call to Photos, then adds the items
     to the destination album. Per-file logs are generated by reconciling imported filenames
     returned by Photos with the staged files.
  3) CLEANUP PROMPT: at the end, you can choose to delete (move to Trash) the staging directory.

Options:
  --from-dir <path>        Target folder to scan. Defaults to current working directory.
  --recursive              Include files in all subfolders of the target directory.
  --dry-run                Show what would be staged/imported without changing anything.
  --album <name>           Destination Photos album (default: "Imported From MacOS").
  --skip-dup-check         Do not check for duplicates (imports everything).
  --no-skip-dup-check      Check for duplicates and skip them (default).
  -h, --help               Show this help and exit.
  -V, --version            Print version and exit.

Supported formats:
  Images: HEIF/HEIC, JPEG/JPG, PNG, GIF, TIFF/TIF, AVIF (best-effort),
          RAW: DNG, CR2/CR3/CRW, NEF/NRW, ARW/SR2/SRF, RAF, RW2/RWL, ORF, SRW,
               PEF, ERF, KDC, FFF, MOS, MRW, MEF, X3F, 3FR, RAW
  Video:  MOV, MP4, M4V, experimental: H.264 elementary stream (.h264)
EOF
}

# --- Platform check ------------------------------------------------------------
if [ "$(uname -s 2>/dev/null)" != "Darwin" ]; then
  echo "‚ùå This script requires macOS (Darwin)."; exit 1
fi

# --- Args ----------------------------------------------------------------------
while [ $# -gt 0 ]; do
  case "$1" in
    --from-dir) TARGET_DIR="$2"; shift 2 ;;
    --recursive) RECURSIVE=1; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    --album) ALBUM_NAME="$2"; shift 2 ;;
    --skip-dup-check) SKIP_DUP_CHECK=true; shift ;;
    --no-skip-dup-check) SKIP_DUP_CHECK=false; shift ;;
    -h|--help) print_help; exit 0 ;;
    -V|--version) echo "$VERSION"; exit 0 ;;
    *) shift ;;
  esac
done

# Resolve target directory
if [ -z "$TARGET_DIR" ]; then
  TARGET_DIR_ABS="$(pwd -P 2>/dev/null)"
else
  if [ ! -d "$TARGET_DIR" ]; then
    echo "‚ùå --from-dir: path is not a directory: $TARGET_DIR"; exit 1
  fi
  TARGET_DIR_ABS="$(cd "$TARGET_DIR" 2>/dev/null && pwd -P)"
fi
[ -n "$TARGET_DIR_ABS" ] || { echo "‚ùå Unable to resolve target directory."; exit 1; }

# --- Banner --------------------------------------------------------------------
echo "üöÄ macOS to Photos Import Script v$VERSION"
echo "========================================="
echo "   Album:      $ALBUM_NAME"
echo "   Target:     $TARGET_DIR_ABS"
[ "$RECURSIVE" -eq 1 ] && echo "   Recursion:  enabled" || echo "   Recursion:  disabled"
[ "$SKIP_DUP_CHECK" = "true" ] && echo "   Duplicates: SKIP CHECK (import everything)" || echo "   Duplicates: CHECK (skip duplicates)"
[ "$DRY_RUN" -eq 1 ] && echo "   Dry-run:    ON (no move/import)"
echo ""

# --- Preflight -----------------------------------------------------------------
if ! command -v osascript >/dev/null 2>&1; then
  echo "‚ùå 'osascript' not found. This script requires macOS AppleScript support."; exit 1
fi

photos_preflight() {
  local res
  res=$(osascript - <<'APPLESCRIPT'
try
  tell application id "com.apple.Photos" to activate
  return "OK"
on error errMsg number errNum
  return "ERR:" & errNum & ":" & errMsg
end try
APPLESCRIPT
)
  case "$res" in
    OK) return 0 ;;
    ERR:*)
      echo "‚ùå Unable to control Photos via AppleScript:"
      echo "   $res"
      echo "   Open Photos once and allow automation in:"
      echo "   System Settings ‚Üí Privacy & Security ‚Üí Automation (Terminal ‚Üí Photos)."
      return 1 ;;
    *) return 0 ;;
  esac
}
[ "$DRY_RUN" -eq 0 ] && photos_preflight || true

ensure_album() {
  osascript - "$ALBUM_NAME" >/dev/null 2>>"$WARN_LOG" <<'APPLESCRIPT'
on run argv
  if (count of argv) is 0 then return
  set albumName to item 1 of argv
  try
    tell application id "com.apple.Photos"
      if (count of (albums whose name is albumName)) = 0 then
        make new album named albumName
      end if
    end tell
  end try
end run
APPLESCRIPT
}
[ "$DRY_RUN" -eq 0 ] && ensure_album

# --- Filters & helpers ---------------------------------------------------------
IMG_EXT=( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' \
          -o -iname '*.tiff' -o -iname '*.tif' -o -iname '*.heic' -o -iname '*.heif' \
          -o -iname '*.avif' \
          -o -iname '*.dng'  -o -iname '*.cr2'  -o -iname '*.cr3'  -o -iname '*.crw' \
          -o -iname '*.nef'  -o -iname '*.nrw'  -o -iname '*.arw'  -o -iname '*.sr2'  -o -iname '*.srf' \
          -o -iname '*.raf'  -o -iname '*.rw2'  -o -iname '*.rwl'  -o -iname '*.orf' \
          -o -iname '*.srw'  -o -iname '*.pef'  -o -iname '*.erf'  -o -iname '*.kdc' \
          -o -iname '*.fff'  -o -iname '*.mos'  -o -iname '*.mrw'  -o -iname '*.mef'  -o -iname '*.x3f' \
          -o -iname '*.3fr'  -o -iname '*.raw' )
VID_EXT=( -iname '*.mp4' -o -iname '*.m4v' -o -iname '*.mov' -o -iname '*.h264' )
UNION=( \( "${IMG_EXT[@]}" -o "${VID_EXT[@]}" \) )
EXCLUDES=( -not -name '._*' -not -name '.DS_Store' -not -name 'Thumbs.db' )

find_files_recursive() { local dir="$1"; shift; find "$dir" -type f \( "$@" \) "${EXCLUDES[@]}" -print0 2>>"$WARN_LOG"; }
find_files_shallow()   { local dir="$1"; shift; find "$dir" \( -type d ! -path "$dir" -prune \) -o \( -type f \( "$@" \) "${EXCLUDES[@]}" -print0 \) 2>>"$WARN_LOG"; }
count_nulls()          { local n=0; while IFS= read -r -d '' _; do n=$((n+1)); done; echo "$n"; }

# --- Phase 1: MOVE_TO_STAGE_DIR ------------------------------------------------
echo "üîç Scanning for Photos-compatible media..."
if [ "$RECURSIVE" -eq 1 ]; then
  icount=$(find_files_recursive "$TARGET_DIR_ABS" "${IMG_EXT[@]}" | count_nulls)
  vcount=$(find_files_recursive "$TARGET_DIR_ABS" "${VID_EXT[@]}" | count_nulls)
else
  icount=$(find_files_shallow   "$TARGET_DIR_ABS" "${IMG_EXT[@]}" | count_nulls)
  vcount=$(find_files_shallow   "$TARGET_DIR_ABS" "${VID_EXT[@]}" | count_nulls)
fi
total_media=$((icount + vcount))
echo "   üìä Found: $icount images, $vcount videos (total: $total_media)"

# Gather candidates BEFORE creating staging dir
CANDIDATES=()
collect_from() {
  local dir="$1"; local reader
  if [ "$RECURSIVE" -eq 1 ]; then reader=(find_files_recursive "$dir" "${UNION[@]}"); else reader=(find_files_shallow "$dir" "${UNION[@]}"); fi
  while IFS= read -r -d '' f; do
    [ -r "$f" ] || { warn "Unreadable (skipped): $f"; continue; }
    CANDIDATES+=( "$f" )
  done < <("${reader[@]}")
}
collect_from "$TARGET_DIR_ABS"

if [ "$DRY_RUN" -eq 1 ]; then
  {
    printf "üß™ Dry run: would stage %s files to ./import2photos_stage_%s\n" "${#CANDIDATES[@]}" "$RUN_TS"
    printf "   (Then import that folder into album \"%s\" in a single Photos call.)\n" "$ALBUM_NAME"
  }
  exit 0
fi

if [ "${#CANDIDATES[@]}" -eq 0 ]; then
  echo "‚ùå No compatible media found to stage. Nothing to import."; exit 0
fi

# Create staging dir under CWD (unique)
STAGE_DIR_BASE="$PWD/import2photos_stage_${RUN_TS}"
STAGE_DIR="$STAGE_DIR_BASE"
i_suf=0
while [ -e "$STAGE_DIR" ]; do
  i_suf=$((i_suf + 1))
  STAGE_DIR="${STAGE_DIR_BASE}_$i_suf"
done
mkdir -p "$STAGE_DIR" 2>>"$WARN_LOG" || { echo "‚ùå Failed to create staging directory."; exit 1; }
STAGE_DIR_ABS="$(cd "$STAGE_DIR" 2>/dev/null && pwd -P)"

echo "üì¶ Staging ${#CANDIDATES[@]} file(s) into:"
echo "   $STAGE_DIR_ABS"

{ printf "# Staged files ‚Äî %s items ‚Äî %s\n" "${#CANDIDATES[@]}" "$RUN_TS"; } >"$STAGED_LOG" 2>>"$WARN_LOG"

staged_count=0
STAGE_SEQ=1

move_one() {
  local src="$1"
  local rel="$1"
  case "$src" in
    "$TARGET_DIR_ABS"/*) rel="${src#"$TARGET_DIR_ABS"/}" ;;
    *) rel="$(basename "$src")" ;;
  esac

  # Build destination directory (preserve relative dirs)
  local dest_dir
  dest_dir="$STAGE_DIR_ABS/$(dirname "$rel")"
  if [ "$dest_dir" = "$STAGE_DIR_ABS/." ]; then dest_dir="$STAGE_DIR_ABS"; fi
  mkdir -p "$dest_dir" 2>>"$WARN_LOG" || return 1

  # Split name/ext; append unique sequential suffix to EVERY file
  local name base ext suffix candidate
  name="$(basename "$rel")"
  case "$name" in *.*) base="${name%.*}"; ext=".${name##*.}" ;; *) base="$name"; ext="" ;; esac
  suffix=" (${STAGE_SEQ})"
  candidate="$dest_dir/$base$suffix$ext"

  # If exists (very unlikely), add a sub-suffix counter
  local n=1
  while [ -e "$candidate" ]; do
    n=$((n+1))
    candidate="$dest_dir/$base (${STAGE_SEQ}-$n)$ext"
  done

  # Copy with preserved metadata; ensure mtime; then remove original
  if cp -p "$src" "$candidate" 2>>"$WARN_LOG"; then
    touch -r "$src" "$candidate" 2>>"$WARN_LOG" || true
    rm -f "$src" 2>>"$WARN_LOG" || warn "Could not remove original after copy: $src"
    { printf "%s\n" "$candidate"; } >>"$STAGED_LOG" 2>>"$WARN_LOG"
    staged_count=$((staged_count + 1))
    STAGE_SEQ=$((STAGE_SEQ + 1))
    return 0
  else
    warn "Failed to copy (stage): $src"
    return 1
  fi
}

for f in "${CANDIDATES[@]}"; do move_one "$f"; done

if [ "$staged_count" -eq 0 ]; then
  echo "‚ùå Staging produced an empty folder. Nothing to import."; exit 1
fi

echo "‚úÖ Staged: $staged_count file(s)"
echo ""

# --- Phase 2: DIRECTORY IMPORT -------------------------------------------------
# AppleScript prints:
#   FN<TAB><filename>   for each imported media item
# or
#   ERR<TAB><code><TAB><message>
import_stage_dir() {
  osascript - "$ALBUM_NAME" "$SKIP_DUP_CHECK" "$STAGE_DIR_ABS" <<'APPLESCRIPT'
on run argv
  if (count of argv) < 3 then return "ERR	0	Missing arguments"
  set albumName to item 1 of argv
  set skipDup to ((item 2 of argv) is "true")
  set dirPath to item 3 of argv

  script util
    on sanitizeText(srcText)
      set oldTIDs to AppleScript's text item delimiters
      set AppleScript's text item delimiters to {return, linefeed, tab}
      set parts to text items of srcText
      set AppleScript's text item delimiters to " "
      set out to parts as text
      set AppleScript's text item delimiters to oldTIDs
      return out
    end sanitizeText
  end script

  try
    set folderAlias to POSIX file (dirPath as text)
  on error errMsg number errNum
    return "ERR	" & (errNum as text) & "	" & errMsg
  end try

  set outLines to {}
  tell application id "com.apple.Photos"
    activate
    try
      if (count of (albums whose name is albumName)) = 0 then make new album named albumName
      set tgtAlbum to first album whose name is albumName
      set importedItems to import folderAlias skip check duplicates skipDup
      if (count of importedItems) > 0 then add importedItems to tgtAlbum
      repeat with mi in importedItems
        try
          set fn to filename of mi
          set fn2 to util's sanitizeText(fn)
          set end of outLines to "FN	" & fn2
        end try
      end repeat
    on error errMsg number errNum
      return "ERR	" & (errNum as text) & "	" & errMsg
    end try
  end tell

  set oldTIDs to AppleScript's text item delimiters
  set AppleScript's text item delimiters to linefeed
  set outText to outLines as text
  set AppleScript's text item delimiters to oldTIDs
  return outText
end run
APPLESCRIPT
}

echo "üì∏ Importing staged folder into Photos..."
import_output="$(import_stage_dir | tr -d '\r')"

# Fatal AppleScript error?
if [[ "$import_output" == ERR$'\t'* ]]; then
  errNum="${import_output#ERR$'\t'}"; errNum="${errNum%%$'\t'*}"
  errMsg="${import_output#ERR$'\t'*}"; errMsg="${errMsg#*$'\t'}"
  {
    printf "# Failed (directory mode) ‚Äî 1 issue ‚Äî %s\n" "$RUN_TS"
    printf "%s\t[%s] %s\n" "$STAGE_DIR_ABS" "$errNum" "$errMsg"
  } >"$FAILED_LOG" 2>>"$WARN_LOG"
  {
    printf "# Duplicates/Skipped ‚Äî unknown (import failed) ‚Äî %s\n" "$RUN_TS"
  } >"$DUP_LOG" 2>>"$WARN_LOG"
  {
    printf "# Imported (directory mode) ‚Äî 0 items ‚Äî %s\n" "$RUN_TS"
    printf "# Folder: %s\n" "$STAGE_DIR_ABS"
  } >"$IMPORTED_LOG" 2>>"$WARN_LOG"

  echo "‚ùå Import failed: [$errNum] $errMsg"
  echo "üßæ Logs saved:"
  echo "   ‚Ä¢ Staged:     $STAGED_LOG"
  echo "   ‚Ä¢ Failed:     $FAILED_LOG"
  echo "   ‚Ä¢ Duplicates: $DUP_LOG"
  echo "   ‚Ä¢ Imported:   $IMPORTED_LOG"
  if [ -s "$WARN_LOG" ]; then
    echo "   ‚Ä¢ Warnings:   $WARN_LOG"
  else
    rm -f "$WARN_LOG" 2>/dev/null
  fi
  exit 1
fi

# Parse imported filenames
IMPORTED_NAMES=()
while IFS= read -r line; do
  [ -z "$line" ] && continue
  case "$line" in
    FN$'\t'*) IMPORTED_NAMES+=( "${line#FN$'\t'}" ) ;;
    *) warn "Unexpected AppleScript line: $line" ;;
  esac
done <<< "$import_output"

# Multiset maps (Bash 3.2-friendly)
NAME_KEYS=()
NAME_COUNTS=()

name_index_of() {
  # echo index or -1
  local key="$1" i
  for ((i=0; i<${#NAME_KEYS[@]}; i++)); do
    [ "${NAME_KEYS[$i]}" = "$key" ] && { echo "$i"; return; }
  done
  echo "-1"
}

name_inc() {
  local key="$1" idx
  idx="$(name_index_of "$key")"
  if [ "$idx" -ge 0 ]; then
    NAME_COUNTS[$idx]=$(( NAME_COUNTS[$idx] + 1 ))
  else
    NAME_KEYS+=( "$key" )
    NAME_COUNTS+=( 1 )
  fi
}

name_dec_if_present() {
  local key="$1" idx
  idx="$(name_index_of "$key")"
  if [ "$idx" -ge 0 ] && [ "${NAME_COUNTS[$idx]}" -gt 0 ]; then
    NAME_COUNTS[$idx]=$(( NAME_COUNTS[$idx] - 1 ))
    return 0
  fi
  return 1
}

for fn in "${IMPORTED_NAMES[@]}"; do name_inc "$fn"; done

IMPORTED_PATHS=()
SKIPPED_PATHS=()

# Build imported vs skipped by matching basenames with multiset counts
while IFS= read -r staged_path; do
  case "$staged_path" in \#*) continue ;; esac
  base="$(basename "$staged_path")"
  if name_dec_if_present "$base"; then
    IMPORTED_PATHS+=( "$staged_path" )
  else
    SKIPPED_PATHS+=( "$staged_path" )
  fi
done < "$STAGED_LOG"

# Logs (grouped redirection to avoid SC2129)
{
  printf "# Imported files ‚Äî %s items ‚Äî %s\n" "${#IMPORTED_PATHS[@]}" "$RUN_TS"
  for p in "${IMPORTED_PATHS[@]}"; do printf "%s\n" "$p"; done
} >"$IMPORTED_LOG" 2>>"$WARN_LOG"

{
  printf "# Duplicates/Skipped ‚Äî %s items ‚Äî %s\n" "${#SKIPPED_PATHS[@]}" "$RUN_TS"
  printf "# Note: Determined by filename reconciliation against Photos 'importedItems'.\n"
  printf "#       When multiple staged files share the same basename, attribution is best-effort.\n"
  for p in "${SKIPPED_PATHS[@]}"; do printf "%s\n" "$p"; done
} >"$DUP_LOG" 2>>"$WARN_LOG"

# Keep FAILED_LOG for fatal errors only; ensure file exists (empty)
: >"$FAILED_LOG" 2>>"$WARN_LOG"

echo "‚úÖ Import finished."
echo "   New items imported: ${#IMPORTED_PATHS[@]}"
echo "   Skipped (duplicates/rejected): ${#SKIPPED_PATHS[@]}"

# --- Post: offer to delete stage dir ------------------------------------------
echo ""
echo "üóëÔ∏è  Do you want to move the staging directory to the Trash?"
echo "   ‚Ä¢ $STAGE_DIR_ABS"
read -p "   Move to Trash? (y/N): " -n 1 -r; echo ""
if [[ $REPLY =~ ^[Yy]$ ]]; then
  echo "üßπ Cleaning up..."
  finder_trash_one() {
    osascript - "$1" >/dev/null 2>>"$WARN_LOG" <<'APPLESCRIPT'
on run argv
  if (count of argv) is 0 then return
  set p to item 1 of argv
  try
    set theAlias to POSIX file (p as text)
  on error
    return
  end try
  try
    tell application "Finder" to delete theAlias
  end try
end run
APPLESCRIPT
  }
  finder_trash_one "$STAGE_DIR_ABS"
  # Fallback if still exists
  if [ -d "$STAGE_DIR_ABS" ]; then
    rm -rf "$STAGE_DIR_ABS" 2>>"$WARN_LOG" || true
  fi
  echo "   ‚úÖ Staging directory removed."
else
  echo "   üìÅ Staging directory kept."
fi

# --- Log summary ---------------------------------------------------------------
echo ""
echo "üßæ Logs saved:"
echo "   ‚Ä¢ Staged:     $STAGED_LOG"
echo "   ‚Ä¢ Imported:   $IMPORTED_LOG"
echo "   ‚Ä¢ Duplicates: $DUP_LOG"
if [ -s "$FAILED_LOG" ]; then echo "   ‚Ä¢ Failed:     $FAILED_LOG"; fi
if [ -s "$WARN_LOG" ]; then
  echo "   ‚Ä¢ Warnings:   $WARN_LOG"
else
  rm -f "$WARN_LOG" 2>/dev/null
fi

echo ""
echo "üì± Check your Photos app for the results."
echo "Done."
